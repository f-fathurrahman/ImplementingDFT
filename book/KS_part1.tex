\chapter{Kohn-Sham equation part I}

In this chapter we will put together tools that we have built in the previous chapters.
Our task is to solve the Kohn-Sham equation:
\begin{equation}
\left[ -\frac{1}{2}\nabla^2 + V_{\mathrm{KS}}(\mathbf{r}) \right]
\psi_{i}(\mathbf{r}) = \epsilon_{i} \psi_{i}(\mathbf{r})
\end{equation}
where $V_{\mathrm{KS}}(\mathbf{r})$ is effective single
particle potential or
the Kohn-Sham potential:
\begin{equation}
V_{\mathrm{KS}}(\mathbf{r}) =
V_{\mathrm{ext}}(\mathbf{r}) + V_{\mathrm{Ha}}(\mathbf{r}) + V_{\mathrm{xc}}(\mathbf{r})
\label{eq:KS_pot_local}
\end{equation}

The external potential $V_{\mathrm{ext}}$ is the potential external to the
electrons. It is usually originated from the interaction between atomic nuclei
and electrons. It also includes any external local potentials such as
confining harmonic potential or Gaussian potential.

Hartree potential is the classical electrostatic interaction energy. It is defined as
\begin{equation}
V_{\mathrm{Ha}}(\mathbf{r}) = \int \frac{\rho(\mathbf{r}')}{\left| \mathbf{r} - \mathbf{r}' \right|}
\,\mathrm{d}\mathbf{r}'
\end{equation}
Given the electron density:
\begin{equation}
\rho(\mathbf{r}) = \sum_{i} f_{i} \psi_{i}^{*}(\mathbf{r}) \psi_{i}(\mathbf{r})
\label{eq:elec_dens_01}
\end{equation}
we can use any methods in Chapter \ref{chap:poisson_3d} to calculate
$V_{\mathrm{Ha}}(\mathbf{r})$.

The exchange correlation potential $V_{\mathrm{xc}}(\mathbf{r})$
is defined as functional derivative of
exchange correlation energy functional $E_{\mathrm{xc}}[\rho(\mathbf{r})]$
\begin{equation}
V_{\mathrm{xc}}(\mathbf{r}) = \frac{\delta E_{\mathrm{xc}}}{\delta \rho(\mathbf{r})}
\end{equation}
We do not have exact closed expression for these quantities, however several
approximations are available.

Solutions to the Kohn-Sham equation are the Kohn-Sham orbitals
$\psi_{i}(\mathrm{r})$ and eigenvalues $\epsilon_{i}$.
Total Kohn-Sham energy can be written as:
\begin{equation}
E^{\mathrm{KS}}_{\mathrm{tot}} = E_{\mathrm{kin}} + E_{\mathrm{ext}}
+ E_{\mathrm{Ha}} + E_{\mathrm{xc}}
\end{equation}
%
The kinetic energy of noninteracting electrons:
\begin{equation}
E_{\mathrm{kin}} = -\frac{1}{2}\sum_{i} \int \psi_{i}^{*}(\mathbf{r}) \nabla^2 \psi_{i}(\mathbf{r})
\,\mathrm{d}\mathbf{r}
\end{equation}
%
External potential energy:
\begin{equation}
E_{\mathrm{ext}} = \int \rho(\mathbf{r}) V_{\mathrm{ext}}(\mathbf{r})
\,\mathrm{d}\mathbf{r}
\end{equation}
%
Hartree energy:
\begin{equation}
E_{\mathrm{ext}} = \int \rho(\mathbf{r}) V_{\mathrm{Ha}}(\mathbf{r})
\,\mathrm{d}\mathbf{r}
\end{equation}
%
XC energy (LDA):
\begin{equation}
E_{\mathrm{ext}} = \int \varepsilon_{\mathrm{xc}}[\rho(\mathbf{r})] \rho(\mathbf{r})
\,\mathrm{d}\mathbf{r}
\end{equation}
where $\varepsilon_{\mathrm{xc}}$ is the XC energy per particle per volume.

Alternative expression of total energy as sum of orbital energies:
\begin{equation}
E^{\mathrm{KS}}_{\mathrm{tot}} = \sum_{i}^{N} \epsilon_{i} - E_{\mathrm{Ha}} + E_{\mathrm{xc}}
- \int \frac{\delta E_{\mathrm{xc}}}{\delta \rho(\mathbf{r})} \rho(\mathbf{r})
\,\mathrm{d}\mathbf{r}
\end{equation}

Nucleus-nucleus interaction energy:
\begin{equation}
E_{\mathrm{tot}} = E^{\mathrm{KS}}_{\mathrm{tot}} + E_{\mathrm{NN}}
\end{equation}



\section{Hartree calculation}

We will ignore the XC potential term in the Kohn-Sham equation.

We will introduce self-consistent field (SCF) method.

New data structure: Hamiltonian

\begin{juliacode}
mutable struct Hamiltonian
  grid::FD3dGrid
  Laplacian::SparseMatrixCSC{Float64,Int64}
  V_Ps_loc::Vector{Float64}
  V_Hartree::Vector{Float64}
  rhoe::Vector{Float64}
  precKin
  precLaplacian
end
\end{juliacode}

\begin{juliacode}
function Hamiltonian( grid, ps_loc_func::Function )
    
  Laplacian = build_nabla2_matrix( grid )
    
  V_Ps_loc = ps_loc_func( grid )
  Npoints = grid.Npoints
    
  V_Hartree = zeros(Float64, Npoints)

  Rhoe = zeros(Float64, Npoints)

  precKin = aspreconditioner( ruge_stuben(-0.5*Laplacian) )
  precLaplacian = aspreconditioner( ruge_stuben(Laplacian) )
    
  return Hamiltonian( grid, Laplacian, V_Ps_loc, V_Hartree, Rhoe, precKin, precLaplacian )
end
\end{juliacode}


\begin{juliacode}
import Base: *
function *( Ham::Hamiltonian, psi::Matrix{Float64} )
  Nbasis = size(psi,1)
  Nstates = size(psi,2)
  Hpsi = zeros(Float64,Nbasis,Nstates)
  # include occupation number factor
  Hpsi = -0.5*Ham.Laplacian * psi #* 2.0
  for ist in 1:Nstates, ip in 1:Nbasis
    Hpsi[ip,ist] = Hpsi[ip,ist] + ( Ham.V_Ps_loc[ip] + Ham.V_Hartree[ip] ) * psi[ip,ist]
  end
  return Hpsi
end
\end{juliacode}

\begin{juliacode}
function update!( Ham::Hamiltonian, Rhoe::Vector{Float64} )
  Ham.rhoe[:] = Rhoe[:]
  Ham.V_Hartree = Poisson_solve_PCG(
      Ham.Laplacian, Ham.precLaplacian, -4*pi*Rhoe, 1000,
      verbose=false, TOL=1e-10
  )
  return
end
\end{juliacode}

Calculate electron density:
\begin{juliacode}
function calc_rhoe( psi::Array{Float64,2} )
  Nbasis = size(psi,1)
  Nstates = size(psi,2)
  Rhoe = zeros(Float64,Nbasis)
  for ist in 1:Nstates
    for ip in 1:Nbasis
      Rhoe[ip] = Rhoe[ip] + 2.0*psi[ip,ist]*psi[ip,ist]
    end
  end
  return Rhoe
end
\end{juliacode}

Calculate energy terms:
\begin{juliacode}
mutable struct Energies
  Kinetic::Float64
  Ps_loc::Float64
  Hartree::Float64
end

import Base: sum
function sum( ene::Energies )
  return ene.Kinetic + ene.Ps_loc + ene.Hartree
end

function calc_E_kin( Ham, psi::Array{Float64,2} )
  Nbasis = size(psi,1)
  Nstates = size(psi,2)
  E_kin = 0.0
  nabla2psi = zeros(Float64,Nbasis)
  dVol = Ham.grid.dVol
  # Assumption: Focc = 2 for all states
  for ist in 1:Nstates
    @views nabla2psi = -0.5*Ham.Laplacian*psi[:,ist]
    E_kin = E_kin + 2.0*dot( psi[:,ist], nabla2psi[:] )*dVol
  end
  return E_kin
end

function calc_energies( Ham::Hamiltonian, psi::Array{Float64,2} )
  dVol = Ham.grid.dVol
  E_kin = calc_E_kin( Ham, psi )
  E_Ps_loc = sum( Ham.V_Ps_loc .* Ham.rhoe )*dVol
  E_Hartree = 0.5*sum( Ham.V_Hartree .* Ham.rhoe )*dVol
  return Energies(E_kin, E_Ps_loc, E_Hartree)
end
\end{juliacode}

Self-consistent field:
\begin{juliacode}
function pot_harmonic( grid; ω=1.0, center=[0.0, 0.0, 0.0] )
  Npoints = grid.Npoints
  Vpot = zeros(Npoints)
  for i in 1:Npoints
    x = grid.r[1,i] - center[1]
    y = grid.r[2,i] - center[2]
    z = grid.r[3,i] - center[3]
    Vpot[i] = 0.5 * ω^2 *( x^2 + y^2 + z^2 )
  end
  return Vpot
end

function main()
  AA = [-3.0, -3.0, -3.0]
  BB = [3.0, 3.0, 3.0]
  NN = [25, 25, 25]

  grid = FD3dGrid( NN, AA, BB )
  my_pot_harmonic( grid ) = pot_harmonic( grid, ω=2 )
  Ham = Hamiltonian( grid, my_pot_harmonic )

  Nbasis = prod(NN)
  dVol = grid.dVol
  Nstates = 4
  psi = rand(Float64,Nbasis,Nstates)
  ortho_sqrt!(psi)
  psi = psi/sqrt(dVol)

  Rhoe = calc_rhoe( psi )
  @printf("Integrated Rhoe = %18.10f\n", sum(Rhoe)*dVol)
  update!( Ham, Rhoe )

  evals = zeros(Float64,Nstates)
  Etot_old = 0.0
  dEtot = 0.0
  betamix = 0.5
  dRhoe = 0.0
  NiterMax = 100

  for iterSCF in 1:NiterMax
    evals = diag_LOBPCG!( Ham, psi, Ham.precKin, verbose_last=true )
    psi = psi/sqrt(dVol)
    Rhoe_new = calc_rhoe( psi )
    @printf("Integrated Rhoe_new = %18.10f\n", sum(Rhoe_new)*dVol)
    Rhoe = betamix*Rhoe_new + (1-betamix)*Rhoe
    @printf("Integrated Rhoe     = %18.10f\n", sum(Rhoe)*dVol)
    update!( Ham, Rhoe )
    Etot = sum( calc_energies( Ham, psi ) )
    dRhoe = norm(Rhoe - Rhoe_new)
    dEtot = abs(Etot - Etot_old)
    @printf("%5d %18.10f %18.10e %18.10e\n", iterSCF, Etot, dEtot, dRhoe)
    if dEtot < 1e-6
      @printf("Convergence is achieved in %d iterations\n", iterSCF)
      for i in 1:Nstates
        @printf("%3d %18.10f\n", i, evals[i])
      end
      break
    end
    Etot_old = Etot
  end
end
\end{juliacode}

\section{Kohn-Sham calculations}

Using XC

Introduction of module:

Electrons type:
\begin{juliacode}
mutable struct Electrons
  Nelectrons::Int64
  Nstates::Int64
  Nstates_occ::Int64
  Focc::Array{Float64,1}
  energies::Array{Float64,1}
end
\end{juliacode}

\begin{juliacode}
function Electrons( Nelectrons::Int64; Nstates_extra=0 )
  is_odd = (Nelectrons%2 == 1)
  Nstates_occ = round(Int64, Nelectrons/2)
  if is_odd
      Nstates_occ = Nstates_occ + 1
  end
  Nstates = Nstates_occ + Nstates_extra
  Focc = zeros(Float64,Nstates)
  energies = zeros(Float64,Nstates)
  if !is_odd
    for i in 1:Nstates_occ
      Focc[i] = 2.0 
    end
  else
    for i in 1:Nstates_occ-1
      Focc[1] = 2.0
    end
    Focc[Nstates_occ] = 1.0
  end
  return Electrons(Nelectrons, Nstates, Nstates_occ, Focc, energies)
end
\end{juliacode}

Example use of Electrons:

New Hamiltonian:
\begin{juliacode}
mutable struct Hamiltonian
  grid::FD3dGrid
  Laplacian::SparseMatrixCSC{Float64,Int64}
  V_Ps_loc::Vector{Float64}
  V_Hartree::Vector{Float64}
  V_XC::Vector{Float64}
  electrons::Electrons
  rhoe::Vector{Float64}
  precKin
  precLaplacian
  energies::Energies
end
\end{juliacode}


Update the potential:

\begin{juliacode}
function update!( Ham::Hamiltonian, Rhoe::Vector{Float64} )
  Ham.rhoe = Rhoe
  Ham.V_Hartree = Poisson_solve_PCG( Ham.Laplacian, Ham.precLaplacian,
    -4*pi*Rhoe, 1000, verbose=false, TOL=1e-10 )
  Ham.V_XC = excVWN( Rhoe ) + Rhoe .* excpVWN( Rhoe )
  return
end
\end{juliacode}

Application of Hamiltonian

\begin{juliacode}
import Base: *
function *( Ham::Hamiltonian, psi::Matrix{Float64} )
  Nbasis = size(psi,1)
  Nstates = size(psi,2)
  Hpsi = zeros(Float64,Nbasis,Nstates)
  Hpsi = -0.5*Ham.Laplacian * psi
  for ist in 1:Nstates, ip in 1:Nbasis
    Hpsi[ip,ist] = Hpsi[ip,ist] + ( Ham.V_Ps_loc[ip] + Ham.V_Hartree[ip] +
                   Ham.V_XC[ip] ) * psi[ip,ist]
  end
  return Hpsi
end
\end{juliacode}