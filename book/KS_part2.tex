\chapter{Kohn-Sham equation part II}
\label{chap:ks_part_2}

In the previous chapters we have used pseudopotentials to model the interaction
between electrons and nuclei. The pseudopotentials that we have used
are limited to local form. In this case, the potential operator is diagonal
in real space. It turns out that it is very difficult to construct local pseudopotentials
that have good accuracy and transferability. Most of the pseudopotentials that
are used in density functional calculations have nonlocal components.

In this chapter, we will use a family of pseudopotentials that was
proposed by Goedecker-Teter-Hutter (GTH) \cite{Goedecker1996} in 1996.
We have used local-only component of this pseudopotential in the previous chapters.
Now, we will start to consider the nonlocal component.

The GTH pseudopotentials can be written in terms of
local $V^{\mathrm{PS}}_{\mathrm{loc}}$ and
angular momentum $l$ dependent
nonlocal components $\Delta V^{\mathrm{PS}}_{l}$:
\begin{equation}
V_{\mathrm{ele-nuc}}(\mathbf{r}) =
\sum_{I} \left[
V^{\mathrm{PS}}_{\mathrm{loc}}(\mathbf{r}-\mathbf{R}_{I}) +
\sum_{l=0}^{l_{\mathrm{max}}}
V^{\mathrm{PS}}_{l}(\mathbf{r}-\mathrm{R}_{I},\mathbf{r}'-\mathbf{R}_{I})
\right]
\end{equation}
%
The local pseudopotential for
$I$-th atom, $V^{\mathrm{PS}}_{\mathrm{loc}}(\mathbf{r}-\mathbf{R}_{I})$,
is radially symmetric
function with the following radial form
\begin{equation}
V^{\mathrm{PS}}_{\mathrm{loc}}(r) =
-\frac{Z_{\mathrm{val}}}{r}\mathrm{erf}\left[
\frac{\bar{r}}{\sqrt{2}} \right] +
\exp\left[-\frac{1}{2}\bar{r}^2\right]\left(
C_{1} + C_{2}\bar{r}^2 + C_{3}\bar{r}^4 + C_{4}\bar{r}^6
\right)
\label{eq:V_ps_loc_R}
\end{equation}
with $\bar{r}=r/r_{\mathrm{loc}}$ and $r_{\mathrm{loc}}$, $Z_{\mathrm{val}}$,
$C_{1}$, $C_{2}$, $C_{3}$ and $C_{4}$ are the corresponding pseudopotential
parameters.
In $\mathbf{G}$-space, the GTH local pseudopotential can be written as
\begin{multline}
V^{\mathrm{PS}}_{\mathrm{loc}}(G) = -\frac{4\pi}{\Omega}\frac{Z_{\mathrm{val}}}{G^2}
\exp\left[-\frac{x^2}{2}\right] +
\sqrt{8\pi^3} \frac{r^{3}_{\mathrm{loc}}}{\Omega}\exp\left[-\frac{x^2}{2}\right]\times\\
\left( C_{1} + C_{2}(3 - x^2) + C_{3}(15 - 10x^2 + x^4) + C_{4}(105 - 105x^2 + 21x^4 - x^6) \right)
\label{eq:V_ps_loc_G}
\end{multline}
where $x=G r_{\mathrm{loc}}$.
%
The nonlocal component of GTH pseudopotential can written in real space as
\begin{equation}
V^{\mathrm{PS}}_{l}(\mathbf{r}-\mathbf{R}_{I},\mathbf{r}'-\mathbf{R}_{I}) =
\sum_{\mu=1}^{N_{l}} \sum_{\nu=1}^{N_{l}} \sum_{m=-l}^{l}
\beta_{\mu lm}(\mathbf{r}-\mathbf{R}_{I})\,
h^{l}_{\mu\nu}\,
\beta^{*}_{\nu lm}(\mathbf{r}'-\mathbf{R}_{I})
\end{equation}
where $\beta_{\mu lm}(\mathbf{r})$ are atomic-centered projector functions
\begin{equation}
\beta_{\mu lm}(\mathbf{r}) = 
p^{l}_{\mu}(r) Y_{lm}(\hat{\mathbf{r}})
\label{eq:proj_NL_R}
\end{equation}
%
and $h^{l}_{\mu\nu}$ are the pseudopotential parameters and
$Y_{lm}$ are the spherical harmonics. Number of projectors per angular
momentum $N_{l}$ may take value up to 3 projectors.
The projectors can be written as
\begin{equation}
p^{l}_{\mu}(r) = \frac{\sqrt{2}}
{r^{l+(4i-1)/2}_{l}\sqrt{\Gamma(l + (4i-1)/2)}} r^{l+2(i-1)}
\exp\left[-\dfrac{r^2}{2r^{2}_{l}}\right] \, ,
\end{equation}
where $\Gamma(x)$ is the gamma function. The projectors are normalized according
to
\begin{equation}
\int_{0}^{\infty} r^2\,p^{l}_{i}(r)\,p^{l}_{i}(r)\,\mathrm{d}r = 1 \, .
\end{equation}

In the case of periodic sytem, the local part of the pseudopotential
is constructed using the formula in the $\mathbf{G}$-space 
and transformed them back to real space.
We refer the readers to the original
reference \cite{Goedecker1996} and the book \cite{Marx2009}
for more information about GTH pseudopotentials.

Due to the separation of local and non-local components of electrons-nuclei
interaction, interaction energy between electron and nuclei can be decomposed as
\begin{equation}
E_{\mathrm{ele-nuc}} = E^{\mathrm{PS}}_{\mathrm{loc}}
+ E^{\mathrm{PS}}_{\mathrm{nloc}}
\end{equation}
%
where the local pseudopotential contribution is
\begin{equation}
E^{\mathrm{PS}}_{\mathrm{loc}} =
\int_{\Omega} \rho(\mathbf{r})\,V^{\mathrm{PS}}_{\mathrm{loc}}(\mathbf{r})\,
\mathrm{d}\mathbf{r}
\end{equation}
%
and the non-local contribution is
\begin{equation}
E^{\mathrm{PS}}_{\mathrm{nloc}} = 
\sum_{i}
f_{i}
\int_{\Omega}\,
\psi^{*}_{i}(\mathbf{r})
\left[
\sum_{I}\sum_{l=0}^{l_{\mathrm{max}}}
V^{\mathrm{PS}}_{l}(\mathbf{r}-\mathbf{R}_{I},\mathbf{r}'-\mathbf{R}_{I})
\right]
\psi_{i}(\mathbf{r})
\,\mathrm{d}\mathbf{r}.
\end{equation}

\begin{juliacode}
struct PsPotNL
  NbetaNL::Int64
  prj2beta::Array{Int64,4}
  betaNL::Array{Float64,2}
end
\end{juliacode}

\begin{juliacode}
function PsPotNL()
  betaNL = zeros(Float64,1,1)
  return PsPotNL( 0, zeros(Int64,1,1,1,1), betaNL )
end
\end{juliacode}

\begin{juliacode}
function PsPotNL( atoms::Atoms, pspots::Array{PsPot_GTH,1}, grid; check_norm=false )
  Natoms = atoms.Natoms
  atm2species = atoms.atm2species
  atpos = atoms.positions

  prj2beta = Array{Int64}(undef,3,Natoms,4,7)
  prj2beta[:] .= -1   # set to invalid index

  NbetaNL = 0
  for ia = 1:Natoms
    isp = atm2species[ia]
    psp = pspots[isp]
    for l = 0:psp.lmax
      for iprj = 1:psp.Nproj_l[l+1]
        for m = -l:l
          NbetaNL = NbetaNL + 1
          prj2beta[iprj,ia,l+1,m+psp.lmax+1] = NbetaNL
        end
      end
    end
  end

  # No nonlocal components
  if NbetaNL == 0
    # return dummy PsPotNL
    betaNL = zeros(Float64,1,1)
    return PsPotNL( 0, zeros(Int64,1,1,1,1), betaNL )
  end

  Npoints = grid.Npoints
  betaNL = zeros(Float64, Npoints, NbetaNL)
  setup_betaNL!( atoms, grid, pspots, betaNL )

  return PsPotNL( NbetaNL, prj2beta, betaNL )
end
\end{juliacode}


The function setup:
\begin{juliacode}
function setup_betaNL!( atoms, grid, pspots, betaNL )
  Natoms = atoms.Natoms
  Npoints = grid.Npoints
  atm2species = atoms.atm2species

  ibeta = 0
  dr = zeros(3)
  for ia = 1:Natoms
    isp = atm2species[ia]
    psp = pspots[isp]
    for l = 0:psp.lmax
    for iprj = 1:psp.Nproj_l[l+1]
    for m = -l:l
      ibeta = ibeta + 1
      for ip in 1:Npoints
        dr[1] = grid.r[1,ip] - atoms.positions[1,ia]
        dr[2] = grid.r[2,ip] - atoms.positions[2,ia]
        dr[3] = grid.r[3,ip] - atoms.positions[3,ia]
        drm = sqrt( dr[1]^2 + dr[2]^2 + dr[3]^2 )
        betaNL[ip,ibeta] = Ylm_real(l, m, dr)*eval_proj_R(psp, l, iprj, drm)
      end
    end # m
    end # iprj
    end # l
  end
  return
end
\end{juliacode}

Calculate energy:
\begin{juliacode}
function calc_E_Ps_nloc( Ham::Hamiltonian, psi::Array{Float64,2} )
  # ... snipped, various shortcuts

  betaNL_psi = calc_betaNL_psi( Ham.pspotNL.betaNL, psi )*dVol

  E_Ps_nloc = 0.0
  for ist = 1:Nstates
    enl1 = 0.0
    for ia = 1:Natoms
      isp = atm2species[ia]
      psp = pspots[isp]
      for l = 0:psp.lmax, m = -l:l
        for iprj = 1:psp.Nproj_l[l+1], jprj = 1:psp.Nproj_l[l+1]
          ibeta = prj2beta[iprj,ia,l+1,m+psp.lmax+1]
          jbeta = prj2beta[jprj,ia,l+1,m+psp.lmax+1]
          hij = psp.h[l+1,iprj,jprj]
          enl1 = enl1 + hij * betaNL_psi[ist,ibeta] * betaNL_psi[ist,jbeta]
        end # jprj
      end # m, l
    end
    E_Ps_nloc = E_Ps_nloc + Focc[ist]*enl1
  end
  return E_Ps_nloc
end
\end{juliacode}

\begin{juliacode}
function op_V_Ps_nloc( Ham::Hamiltonian, psi::Array{Float64,2} )
  # ... snipped

  betaNL_psi = psi' * Ham.pspotNL.betaNL * dVol
  
  Vpsi = zeros(Float64,Npoints,Nstates)
  for ist = 1:Nstates
    for ia = 1:Natoms
      isp = atm2species[ia]
      psp = pspots[isp]
      for l = 0:psp.lmax, m = -l:l
        for iprj = 1:psp.Nproj_l[l+1], jprj = 1:psp.Nproj_l[l+1]
          ibeta = prj2beta[iprj,ia,l+1,m+psp.lmax+1]
          jbeta = prj2beta[jprj,ia,l+1,m+psp.lmax+1]
          hij = psp.h[l+1,iprj,jprj]
          for ip = 1:Npoints
              Vpsi[ip,ist] = Vpsi[ip,ist] + hij*betaNL[ip,ibeta]*betaNL_psi[ist,jbeta]
          end
        end # jprj, iprj
      end # m, l
    end # ia
  end # ist
  return Vpsi
end
\end{juliacode}


\begin{juliacode}
import Base: *
function *( Ham::Hamiltonian, psi::Matrix{Float64} )
  Nbasis = size(psi,1)
  Nstates = size(psi,2)
  Hpsi = -0.5*Ham.Laplacian*psi
  if Ham.pspotNL.NbetaNL > 0
    Vnlpsi = op_V_Ps_nloc(Ham, psi)
    for ist in 1:Nstates, ip in 1:Nbasis
        Hpsi[ip,ist] = Hpsi[ip,ist] + ( Ham.V_Ps_loc[ip] +
            Ham.V_Hartree[ip] + Ham.V_XC[ip] ) * psi[ip,ist] + Vnlpsi[ip,ist]
    end
  else # no nonlocal pspot components
    for ist in 1:Nstates, ip in 1:Nbasis
            Hpsi[ip,ist] = Hpsi[ip,ist] + ( Ham.V_Ps_loc[ip] +
                Ham.V_Hartree[ip] + Ham.V_XC[ip] ) * psi[ip,ist]
    end
  end
  return Hpsi
end
\end{juliacode}